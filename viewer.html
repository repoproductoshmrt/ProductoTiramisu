<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <title>Visor PDF con Zoom</title>
  <style>
    :root{ --maxw:clamp(420px,70vw,960px) }  /* más ancho en desktop */
    @media (max-width: 520px){
      :root{ --maxw: 100vw; }                /* en móvil ocupa todo */
    }
    html,body{ margin:0; padding:0; background:#f6f7f8 }

    .wrap{
      max-width:var(--maxw);
      margin:0 auto;
      padding:12px 8px 40px;
      overflow-x:auto;                 /* scroll lateral con zoom */
      touch-action: pan-x pan-y;       /* pan 1 dedo; pinch lo gestionamos nosotros */
      -webkit-overflow-scrolling: touch;
    }

    .t{font:600 16px/1.35 system-ui;margin:6px 0 12px;opacity:.9}

    #controls{
      position: sticky;
      top: 0;
      z-index: 9999;                   /* ✅ por encima de todo */
      background: #f6f7f8;
      margin: 10px 0;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 0;
    }
    #controls button{
      padding:4px 10px;
      font-size:16px;
      cursor:pointer;
    }
    #zoomLevel{font:500 14px system-ui}

    #pages{ width:max-content; }
    .p{
      position:relative;
      margin:10px 0;
      background:#fff;
      box-shadow:0 1px 6px rgba(0,0,0,.08);
      width:max-content;
    }
    .ph{
      width:100%; aspect-ratio:1/1.414;
      display:grid;place-items:center;
      color:#999;background:#fff;font:500 13px system-ui
    }
    /* ✅ el canvas no captura clics; el scroll sigue funcionando en el contenedor */
    canvas{ width:100%; height:auto; display:block; pointer-events:none; }
  </style>
</head>
<body>
  <div class="wrap" id="viewport">
    <div class="t" id="docTitle">Cargando…</div>

    <div id="controls">
      <button id="btnZoomOut" type="button" aria-label="Reducir zoom">-</button>
      <button id="btnZoomIn"  type="button" aria-label="Ampliar zoom">+</button>
      <span id="zoomLevel">100%</span>
    </div>

    <div id="pages"></div>
  </div>

  <!-- PDF.js desde tu repo -->
  <script src="vendor/pdfjs/pdf.min.js"></script>

  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = "vendor/pdfjs/pdf.worker.min.js";

    const q=new URLSearchParams(location.search);
    const fileParam=q.get("file");
    const fileURL=fileParam
      ? (/^https?:\/\//i.test(fileParam) ? fileParam : new URL(fileParam,location.href).toString())
      : null;

    const title=q.get("title")||"Lectura";
    const DPR=Math.min(window.devicePixelRatio||1.25,2);
    const wrap=document.getElementById("viewport");
    const pages=document.getElementById("pages");
    document.getElementById("docTitle").textContent=title;

    let pdf=null,states=[];
    let currentScale = 1.0; // 100%
    const io=new IntersectionObserver(onIO,{root:null,rootMargin:"1200px 0px",threshold:.01});

    function containerWidth(){
      return wrap.clientWidth || document.documentElement.clientWidth;
    }

    function pageDiv(n){
      const d=document.createElement("div"); d.className="p"; d.dataset.i=n-1;
      const ph=document.createElement("div"); ph.className="ph"; ph.textContent="Página "+n; d.appendChild(ph);
      const c=document.createElement("canvas"); c.style.display="none"; d.appendChild(c);
      return{div:d,canvas:c}
    }

    async function render(st){
      if(st.rendering||st.rendered)return;
      st.rendering=true;
      try{
        const page=await pdf.getPage(st.num);
        const w = containerWidth();
        const v0=page.getViewport({scale:1});
        const s =(w/v0.width)*currentScale;
        const v =page.getViewport({scale:s});

        const cv=st.canvas,ctx=cv.getContext("2d");
        cv.width =Math.floor(v.width *DPR);
        cv.height=Math.floor(v.height*DPR);
        cv.style.width =v.width +"px";
        cv.style.height=v.height+"px";

        st.div.style.width = v.width + "px";

        await page.render({canvasContext:ctx,viewport:v.clone({scale:s*DPR})}).promise;
        st.div.querySelector(".ph")?.remove();
        cv.style.display="";
        st.rendered=true;
      }catch(e){
        st.div.innerHTML='<div class="ph">Error al cargar</div>';
        console.error(e);
      }
      st.rendering=false;
    }

    function onIO(entries){
      entries.forEach(en=>{
        const st=states[+en.target.dataset.i]; if(!st)return;
        if(en.isIntersecting){
          render(st);
          for(let i=1;i<=2;i++){
            const nx=states[+en.target.dataset.i+i];
            if(nx&&!nx.rendered)render(nx);
          }
        }
      });
    }

    function rerenderVisible(){
      document.querySelectorAll(".p").forEach(el=>{
        const i=+el.dataset.i,st=states[i]; if(!st)return;
        const r=el.getBoundingClientRect(),vis=r.bottom>0&&r.top<innerHeight;
        if(vis){st.rendered=false;render(st);}
      });
    }

    addEventListener("resize", rerenderVisible);
    addEventListener("orientationchange", ()=>{ setTimeout(rerenderAll, 200); });

    (async function init(){
      if(!fileURL){
        pages.innerHTML='<div class="ph">Falta ?file=/ruta/al.pdf</div>';
        return;
      }
      try{
        pdf=await pdfjsLib.getDocument({url:fileURL,withCredentials:false}).promise;
        for(let i=1;i<=pdf.numPages;i++){
          const {div,canvas}=pageDiv(i);
          pages.appendChild(div);
          states.push({num:i,div,canvas,rendered:false,rendering:false});
          io.observe(div);
        }
        const first = states[0]; if(first){ first.rendered=false; render(first); }
        requestAnimationFrame(()=>rerenderAll());
        setTimeout(rerenderAll, 250);
      }catch(err){
        pages.innerHTML='<div class="ph">No se pudo abrir el PDF</div>';
        console.error("getDocument error:",err);
      }
    })();

    // ====== Zoom (funciones) ======
    function zoomIn(){ currentScale = Math.min(currentScale + 0.1, 3); rerenderAll(); }
    function zoomOut(){ currentScale = Math.max(currentScale - 0.1, 0.5); rerenderAll(); }
    function rerenderAll(){
      document.getElementById("zoomLevel").textContent = Math.round(currentScale*100)+"%";
      states.forEach(st=>{st.rendered=false;render(st);});
    }

    // ====== Enlazar botones (click + pointerdown) ======
    (function bindZoomButtons(){
      const inBtn  = document.getElementById('btnZoomIn');
      const outBtn = document.getElementById('btnZoomOut');
      const bind = (el, fn)=>{
        if (!el) return;
        el.addEventListener('click', fn);
        el.addEventListener('pointerdown', fn);   // por si el click se pierde en algunos iframes
      };
      bind(inBtn,  zoomIn);
      bind(outBtn, zoomOut);
    })();

    // ====== Pinch-to-Zoom: Pointer Events ======
    (function enablePinchZoomPointer(){
      const el = document.getElementById('viewport');
      if (!window.PointerEvent) return; // si no hay soporte, que el fallback Touch se encargue
      const pointers = new Map();
      let startDistance = 0;
      let startScale = 1;
      let raf = null;
      let pinching = false;

      function distance(a, b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

      function onPointerDown(e){
        if (!el.contains(e.target)) return;
        el.setPointerCapture?.(e.pointerId);
        pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
        if (pointers.size === 2){
          const [p1, p2] = [...pointers.values()];
          startDistance = distance(p1, p2) || 1;
          startScale = currentScale;
          pinching = true;
          el.style.touchAction = 'none';
        }
      }
      function onPointerMove(e){
        if (!pointers.has(e.pointerId)) return;
        pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
        if (pinching && pointers.size === 2){
          const [p1, p2] = [...pointers.values()];
          const factor = (distance(p1,p2)||1)/startDistance;
          const next = Math.min(3, Math.max(0.5, startScale*factor));
          if (next !== currentScale){
            currentScale = next;
            if (!raf){
              raf = requestAnimationFrame(()=>{
                raf=null;
                document.getElementById('zoomLevel').textContent = Math.round(currentScale*100)+'%';
                states.forEach(st=>{ st.rendered=false; render(st); });
              });
            }
          }
        }
      }
      function endPointer(e){
        pointers.delete(e.pointerId);
        if (pointers.size < 2 && pinching){
          pinching = false;
          el.style.touchAction = 'pan-x pan-y';
        }
      }
      el.addEventListener('pointerdown', onPointerDown, {passive:true});
      el.addEventListener('pointermove', onPointerMove, {passive:true});
      el.addEventListener('pointerup', endPointer, {passive:true});
      el.addEventListener('pointercancel', endPointer, {passive:true});
      el.addEventListener('pointerleave', endPointer, {passive:true});
    })();

    // ====== Pinch-to-Zoom: fallback Touch (iOS/Safari en iframes) ======
    (function enablePinchZoomTouch(){
      const el = document.getElementById('viewport');
      let touching = false;
      let startDistance = 0;
      let startScale = 1;
      let raf = null;

      function getTouches(e){
        const t0 = e.touches[0], t1 = e.touches[1];
        return t1 ? [{x:t0.clientX, y:t0.clientY},{x:t1.clientX, y:t1.clientY}] : null;
      }
      function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

      el.addEventListener('touchstart', (e)=>{
        if (e.touches.length === 2){
          const pts = getTouches(e); if (!pts) return;
          touching = true;
          startDistance = dist(pts[0], pts[1]) || 1;
          startScale = currentScale;
          e.preventDefault();
        }
      }, {passive:false});

      el.addEventListener('touchmove', (e)=>{
        if (!touching || e.touches.length !== 2) return;
        const pts = getTouches(e); if (!pts) return;
        const factor = (dist(pts[0], pts[1]) || 1) / startDistance;
        const next = Math.min(3, Math.max(0.5, startScale * factor));
        if (next !== currentScale){
          currentScale = next;
          if (!raf){
            e.preventDefault();
            raf = requestAnimationFrame(()=>{
              raf=null;
              document.getElementById('zoomLevel').textContent = Math.round(currentScale*100)+'%';
              states.forEach(st=>{ st.rendered=false; render(st); });
            });
          }
        }else{
          e.preventDefault();
        }
      }, {passive:false});

      function endTouch(e){
        if (e.touches.length < 2) touching = false;
      }
      el.addEventListener('touchend', endTouch, {passive:true});
      el.addEventListener('touchcancel', endTouch, {passive:true});
    })();
  </script>
</body>
</html>
